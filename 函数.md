#一、函数定义与调用
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。

Python 中函数的应用非常广泛，如 input() 、print()、range()、len() 函数等等，这些都是 Python 的内置函数，可以直接使用。

除了可以直接使用的内置函数外，Python 还支持自定义函数，即将一段有规律的、可重复使用的代码定义成函数，从而达到一次编写、多次调用的目的。

##1、函数的定义
定义函数，也就是创建一个函数，可以理解为创建一个具有某些用途的工具。定义函数需要用 def 关键字实现，具体的语法格式如下：

	def 函数名(参数列表):
	    //实现特定功能的多行代码
	    [return [返回值]]

其中，用 [] 括起来的为可选择部分，即可以使用，也可以省略。


此格式中，各部分参数的含义如下：

函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能（如上面的 my_len，即表示我们自定义的 len() 函数）。

形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。

[return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。

注意，在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。另外，如果想定义一个没有任何功能的空函数，可以使用 pass 语句作为占位符。

##2、函数的调用

调用函数也就是执行函数。如果把创建的函数理解为一个具有某种用途的工具，那么调用函数就相当于使用该工具。

函数调用的基本语法格式如下所示：

	[返回值] = 函数名([形参值])

其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。

需要注意的是，创建函数有多少个形参，那么调用时就需要传入多少个值，且顺序必须和创建函数时一致。即便该函数没有参数，函数名后的小括号也不能省略。

#二、函数参数
##1、形参实参
通常情况下，定义函数时都会选择有参数的函数形式，函数参数的作用是传递数据给函数，令其对接收的数据做具体的操作处理。

在使用函数时，经常会用到形式参数（简称“形参”）和实际参数（简称“实参”），二者都叫参数，之间的区别是：

形式参数：在定义函数时，函数名后面括号中的参数就是形式参数，例如:

	#定义函数时，这里的函数参数 obj 就是形式参数
	def demo(obj):
	    print(obj)

实际参数：在调用函数时，函数名后面括号中的参数称为实际参数，也就是函数的调用者给函数的参数。例如:

	a = "gcn"
	#调用已经定义好的 demo 函数，此时传入的函数参数 a 就是实际参数
	demo(a)

实参和形参的区别，就如同剧本选主角，剧本中的角色相当于形参，而演角色的演员就相当于实参。

Python 中，根据实际参数的类型不同，函数参数的传递方式可分为 2 种，分别为值传递和引用（地址）传递：

值传递：适用于实参类型为不可变类型（字符串、数字、元组）；

引用（地址）传递：适用于实参类型为可变类型（列表，字典）；

值传递和引用传递的区别是，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。

例如，定义一个名为 demo 的函数，分别为传入一个字符串类型的变量（代表值传递）和列表类型的变量（代表引用传递）：
	
	def demo(obj) :
	    obj += obj
	    print("形参值为：",obj)
	print("-------值传递-----")
	a = "gcn"
	print("a的值为：",a)
	demo(a)
	print("实参值为：",a)
	print("-----引用传递-----")
	a = [1,2,3]
	print("a的值为：",a)
	demo(a)
	print("实参值为：",a)

运行结果为：

	-------值传递-----
	a的值为： gcn
	形参值为： gcngcn
	实参值为： gcn
	-----引用传递-----
	a的值为： [1, 2, 3]
	形参值为： [1, 2, 3, 1, 2, 3]
	实参值为： [1, 2, 3, 1, 2, 3]

分析运行结果不难看出，在执行值传递时，改变形式参数的值，实际参数并不会发生改变；而在进行引用传递时，改变形式参数的值，实际参数也会发生同样的改变。

##2、位置参数
位置参数，有时也称必备参数，指的是必须按照正确的顺序将实际参数传到函数中，换句话说，调用函数时传入实际参数的数量和位置都必须和定义函数时保持一致。

实参和形参数量必须一致；实参和形参位置必须一致。

在调用函数，指定的实际参数的数量，必须和形式参数的数量一致（传多传少都不行），否则 Python 解释器会抛出 TypeError 异常，并提示缺少必要的位置参数。

再调用函数时，传入实际参数的位置必须和形式参数位置一一对应。

##3、关键字参数
关键字参数是指使用形式参数的名字来确定输入的参数值。通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。
因此，Python 函数的参数名应该具有更好的语义，这样程序可以立刻明确传入函数的每个参数的含义。

##4、默认参数
在调用函数时如果不指定某个参数，Python 解释器会抛出异常。为了解决这个问题，Python 允许为参数设置默认值，即在定义函数时，直接给形式参数指定一个默认值。这样的话，即便调用函数时没有给拥有默认值的形参传递参数，该参数可以直接使用定义函数时设置的默认值。

Python 定义带有默认值参数的函数，其语法格式如下：

	def 函数名(...，形参名，形参名=默认值)：
	    代码块

注意，在使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。

#三、函数返回值
Python中，用 def 语句创建函数时，可以用 return 语句指定应该返回的值，该返回值可以是任意类型。需要注意的是，return 语句在同一函数中可以出现多次，但只要有一个得到执行，就会直接结束函数的执行。

函数中，使用 return 语句的语法格式如下：

	return [返回值]

其中，返回值参数可以指定，也可以省略不写（将返回空值 None）。

示例：

	def add(a,b):
	    c = a + b
	    return c
	#函数赋值给变量
	c = add(3,4)
	print(c)
	#函数返回值作为其他函数的实际参数
	print(add(3,4))

运行结果为：

	7
	7
本例中，add() 函数既可以用来计算两个数的和，也可以连接两个字符串，它会返回计算的结果。

通过 return 语句指定返回值后，我们在调用函数时，既可以将该函数赋值给一个变量，用变量保存函数的返回值，也可以将函数再作为某个函数的实际参数。

函数中可以同时包含多个 return 语句，但需要注意的是，最终真正执行的做多只有 1 个，且一旦执行，函数运行会立即结束。

#四、函数递归
在一个函数体内调用它自身，被称为函数递归。函数递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。

己知有一个数列：f(0) = 1，f(1) = 4，f(n + 2) = 2*f(n+ 1) +f(n)，其中 n 是大于 0 的整数，求 f(10) 的值。这道题可以使用递归来求得。下面程序将定义一个 fn() 函数，用于计算 f(10) 的值。

	def fn(n) :
    	if n == 0 :
    	    return 1
    	elif n == 1 :
    	    return 4
    	else :
    	    # 函数中调用它自身，就是函数递归
    	    return 2 * fn(n - 1) + fn(n - 2)
	# 输出fn(10)的结果
	print("fn(10)的结果是:", fn(10))


  在上面的 fn() 函数体中再次调用了 fn() 函数，这就是函数递归。注意在 fn() 函数体中调用 fn 的形式：
 
	return 2 * fn(n - 1) + fn(n - 2)



  对于 fn(10)，即等于 2*fn(9)+fn(8)，其中 fn(9) 又等于 2*fn(8)+fn(7)……依此类推，最终会计算到 fn(2) 等于 2*fn(1)+fn(0)，即 fn(2) 是可计算的，这样递归带来的隐式循环就有结束的时候，然后一路反算回去，最后就可以得到 fn(10) 的值。

  仔细看上面递归的过程，当一个函数不断地调用它自身时，必须在某个时刻函数的返回值是确定的，即不再调用它自身：否则，这种递归就变成了无穷递归，类似于死循环。因此，在定义递归函数时有一条最重要的规定： 递归一定要向已知方向进行。

递归是非常有用的，例如程序希望遍历某个路径下的所有文件，但这个路径下的文件夹的深度是未知的，那么就可以使用递归来实现这个需求。系统可定义一个函数，该函数接收一个文件路径作为参数，该函数可遍历出当前路径下的所有文件和文件路径，即在该函数的函数体中再次调用函数自身来处理该路径下的所有文件路径。总之，只要在一个函数的函数体中调用了函数自身，就是函数递归。递归一定要向已知方向进行。


#五、函数注解
Python3提供一种语法，用于为函数声明中的参数和返回值附加元数据，或者也可以称之为注释。

	def my_function():
	    """
	    Something about your function…
	    """
	    pass
	 
	# 文档注释可以通过下面这种方式查看
	print(my_function.__doc__)

言归正传，看代码：

	def test(x, y) -> int:
	    return x + y

上述代码中的 ->int 告诉使用者该函数返回值将会是 int 类型。

也可以给函数参数加上注解，比如：

	def func(text:str, max_len:'int>0' = 80) -> str:
	    pass

text 参数后面加个 : (冒号)接着写类型，如果参数有默认值，则在 : 和 = 之间加上类型。

这些注释信息都是函数的元信息，保存在FuntionName.__annotations__字典中(这里的FunctionName为调用函数名)。

	def func(ham: 42, eggs: int = 'spam') -> "Nothing in here":
	    print("函数注释", func.__annotations__)
	    print("参数值打印", ham, eggs)
	    print(type(ham), type(eggs))
	 
	func("www")
上面代码运行结果：

	函数注释 {'ham': 42, 'eggs': <class 'int'>, 'return': 'Nothing in here'}
	参数值打印 www spam
	<class 'str'> <class 'str'>

参数:后面是注解表达式，可以用来注解参数类型和约束。如果参数有默认值，注解放在参数名和=号之间。

可以在函数末尾的)和:之间添加->和注解表达式，来对返回值添加注解。

注解表达式可以是任何类型，最常用的类型是类（如str或int）和字符串（如’int > 0’）。

函数注解只是个注解，Python对注解所做的唯一的事情是，把它们存入函数的__annotations__属性中：

Python不做检查，不做强制，不做验证，什么操作都不做！注解只是元数据，可以供框架和IDE等工具使用。

#六、变量作用域
所谓作用域（Scope），就是变量的有效范围，就是变量可以在哪个范围以内使用。有些变量可以在整段代码的任意位置使用，有些变量只能在函数内部使用，有些变量只能在 for 循环内部使用。

变量的作用域由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。

##1、Python局部变量
在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。

要知道，当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。

##2、Python全局变量
除了在函数内部定义变量，Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。

和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。

##3、获取指定作用域范围中的变量
在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：

###1) globals()函数
globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。


###2) locals()函数
locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。这里所谓的“当前作用域”指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。


###3) vars(object)
vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。

# python文件操作

Python 中，对文件的操作有很多种，常见的操作包括创建、删除、修改权限、读取、写入等，这些操作可大致分为以下 2 类：

删除、修改权限：作用于文件本身，属于系统级操作。

写入、读取：是文件最常用的操作，作用于文件的内容，属于应用级操作。

其中，对文件的系统级操作功能单一，比较容易实现，可以借助 Python 中的专用模块（os、sys 等），并调用模块中的指定函数来实现。例如，假设如下代码文件的同级目录中有一个文件“a.txt”，通过调用 os 模块中的 remove 函数，可以将该文件删除，具体实现代码如下：

	import os
	os.remove("a.txt")

而对于文件的应用级操作，通常需要按照固定的步骤进行操作，且实现过程相对比较复杂。

文件的应用级操作可以分为以下 3 步，每一步都需要借助对应的函数实现：

打开文件：使用 open() 函数，该函数会返回一个文件对象；

对已打开文件做读/写操作：读取文件内容可使用 read()、readline() 以及 readlines() 函数；向文件中写入内容，可以使用 write() 函数。

关闭文件：完成对文件的读/写操作之后，最后需要关闭文件，可以使用 close() 函数。

一个文件，必须在打开之后才能对其进行操作，并且在操作结束之后，还应该将其关闭，这 3 步的顺序不能打乱。

## 1、open()函数

如果想要操作文件，首先需要创建或者打开指定的文件，并创建一个文件对象，而这些工作可以通过内置的 open() 函数实现。

open() 函数用于创建或打开指定文件，该函数的常用语法格式如下：

	file = open(file_name [, mode='r' [ , buffering=-1 [ , encoding = None ]]])

此格式中，用 [] 括起来的部分为可选参数，即可以使用也可以省略。其中，各个参数所代表的含义如下：

file：表示要创建的文件对象。

file_name：要创建或打开文件的文件名称，该名称要用引号（单引号或双引号都可以）括起来。需要注意的是，如果要打开的文件和当前执行的代码文件位于同一目录，则直接写文件名即可；否则，此参数需要指定打开文件所在的完整路径。

mode：可选参数，用于指定文件的打开模式。可选的打开模式如表 1 所示。如果不写，则默认以只读（r）模式打开文件。

buffering：可选参数，用于指定对文件做读写操作时，是否使用缓冲区（本节后续会详细介绍）。

encoding：手动设定打开文件时所使用的编码格式，不同平台的 ecoding 参数值也不同，以 Windows 为例，其默认为 cp936（实际上就是 GBK 编码）。

mode参数包括：

	t	文本模式 (默认)。
	x	写模式，新建一个文件，如果该文件已存在则会报错。
	b	二进制模式。
	+	打开一个文件进行更新(可读可写)。
	U	通用换行模式（Python 3 不支持）。
	r	以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
	rb	以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。
	r+	打开一个文件用于读写。文件指针将会放在文件的开头。
	rb+	以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。
	w	打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
	wb	以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
	w+	打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。
	wb+	以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。
	a	打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
	ab	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
	a+	打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。
	ab+	以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。

成功打开文件之后，可以调用文件对象本身拥有的属性获取当前文件的部分信息，其常见的属性为：

file.name：返回文件的名称；

file.mode：返回打开文件时，采用的文件打开模式；

file.encoding：返回打开文件时使用的编码格式；

file.closed：判断文件是否己经关闭。

## 2、read()函数

Python 提供了如下 3 种函数，它们都可以帮我们实现读取文件中数据的操作：

read() 函数：逐个字节或者字符读取文件中的内容；

readline() 函数：逐行读取文件中的内容；

readlines() 函数：一次性读取文件中多行内容。

1）read()函数
对于借助 open() 函数，并以可读模式（包括 r、r+、rb、rb+）打开的文件，可以调用 read() 函数逐个字节（或者逐个字符）读取文件中的内容。
如果文件是以文本模式（非二进制模式）打开的，则 read() 函数会逐个字符进行读取；反之，如果文件以二进制模式打开，则 read() 函数会逐个字节进行读取。

read() 函数的基本语法格式如下：

	file.read([size])

其中，file 表示已打开的文件对象；size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。

2）readline()函数

readline() 函数用于读取文件中的一行，包含最后的换行符“\n”。此函数的基本语法格式为：

	file.readline([size])	

其中，file 为打开的文件对象；size 为可选参数，用于指定读取每一行时，一次最多读取的字符（字节）数。

和 read() 函数一样，此函数成功读取文件数据的前提是，使用 open() 函数指定打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。

3）readlines()函数

readlines() 函数用于读取文件中的所有行，它和调用不指定 size 参数的 read() 函数类似，只不过该函数返回是一个字符串列表，其中每个元素为文件中的一行内容。

和 readline() 函数一样，readlines() 函数在读取每一行时，会连同行尾的换行符一块读取。

readlines() 函数的基本语法格式如下：

	file.readlines()

其中，file 为打开的文件对象。和 read()、readline() 函数一样，它要求打开文件的模式必须为可读模式（包括 r、rb、r+、rb+ 4 种）。

## 3、写入数据

1）Python 中的文件对象提供了 write() 函数，可以向文件中写入指定内容。该函数的语法格式如下：

	file.write(string)

其中，file 表示已经打开的文件对象；string 表示要写入文件的字符串（或字节串，仅适用写入二进制文件中）。

注意，在使用 write() 向文件中写入数据，需保证使用 open() 函数是以 r+、w、w+、a 或 a+ 的模式打开文件，否则执行 write() 函数会抛出 io.UnsupportedOperation 错误。

例如，创建一个 a.txt 文件，该文件内容如下：
	
	python
	deeplearning

然后，在和 a.txt 文件同级目录下，创建一个 Python 文件，编写如下代码：
	
	f = open("a.txt", 'w')
	f.write("写入一行新数据")
	f.close()

前面已经讲过，如果打开文件模式中包含 w（写入），那么向文件中写入内容时，会先清空原文件中的内容，然后再写入新的内容。因此运行上面程序，再次打开 a.txt 文件，只会看到新写入的内容：

	写入一行新数据

2）writelines()函数

Python 的文件对象中，不仅提供了 write() 函数，还提供了 writelines() 函数，可以实现将字符串列表写入文件中。

注意，写入函数只有 write() 和 writelines() 函数，而没有名为 writeline 的函数。

例如，还是以 a.txt 文件为例，通过使用 writelines() 函数，可以轻松实现将 a.txt 文件中的数据复制到其它文件中，实现代码如下：

	f = open('a.txt', 'r')
	n = open('b.txt','w+')
	n.writelines(f.readlines())
	n.close()
	f.close()

执行此代码，在 a.txt 文件同级目录下会生成一个 b.txt 文件，且该文件中包含的数据和 a.txt 完全一样。

需要注意的是，使用 writelines() 函数向文件中写入多行数据时，不会自动给各行添加换行符。上面例子中，之所以 b.txt 文件中会逐行显示数据，是因为 readlines() 函数在读取各行数据时，读入了行尾的换行符。


## 4、关闭文件

close() 函数是专门用来关闭已打开文件的，其语法格式也很简单，如下所示：

file.close()

其中，file 表示已打开的文件对象。

文件在打开并操作完成之后，就应该及时关闭，否则程序的运行可能出现问题。

## 5、with as

任何一门编程语言中，文件的输入输出、数据库的连接断开等，都是很常见的资源管理操作。但资源都是有限的，在写程序时，必须保证这些资源在使用过后得到释放，不然就容易造成资源泄露，轻者使得系统处理缓慢，严重时会使系统崩溃。

例如，前面在介绍文件操作时，一直强调打开的文件最后一定要关闭，否则会程序的运行造成意想不到的隐患。但是，即便使用 close() 做好了关闭文件的操作，如果在打开文件或文件操作过程中抛出了异常，还是无法及时关闭文件。

为了更好地避免此类问题，不同的编程语言都引入了不同的机制。在 Python 中，对应的解决方式是使用 with as 语句操作上下文管理器（context manager），它能够帮助我们自动分配并且释放资源。

简单的理解，同时包含 __enter__() 和 __exit__() 方法的对象就是上下文管理器。常见构建上下文管理器的方式有 2 种，分别是基于类实现和基于生成器实现，例如，使用 with as 操作已经打开的文件对象（本身就是上下文管理器），无论期间是否抛出异常，都能保证 with as 语句执行完毕后自动关闭已经打开的文件。

首先学习如何使用 with as 语句。with as 语句的基本语法格式为：

	with 表达式 [as target]：
	    代码块

此格式中，用 [] 括起来的部分可以使用，也可以省略。其中，target 参数用于指定一个变量，该语句会将 expression 指定的结果保存到该变量中。with as 语句中的代码块如果不想执行任何语句，可以直接使用 pass 语句代替。

举个例子，假设有一个 a.txt 文件，其存储内容如下：

	aaa
	bbb


在和 a.txt 同级目录下，创建一个 .py 文件，并编写如下代码：

	with open('a.txt', 'a') as f:
	    f.write("ccc")

运行结果为：

	aaa
	bbb
	ccc

可以看到，通过使用 with as 语句，即便最终没有关闭文件，修改文件内容的操作也能成功。


# python异常处理机制

程序运行时常会碰到一些错误，例如除数为 0、年龄为负数、数组下标越界等，这些错误如果不能发现并加以处理，很可能会导致程序崩溃。

和 C++、Java 这些编程语言一样，Python 也提供了处理异常的机制，可以让我们捕获并处理这些错误，让程序继续沿着一条不会出错的路径执行。

可以简单的理解异常处理机制，就是在程序运行出现错误时，让 Python 解释器执行事先准备好的除错程序，进而尝试恢复程序的执行。

借助异常处理机制，甚至在程序崩溃前也可以做一些必要的工作，例如将内存中的数据写入文件、关闭打开的文件、释放分配的内存等。

Python 异常处理机制会涉及 try、except、else、finally 这 4 个关键字，同时还提供了可主动使程序引发异常的 raise 语句。

总的来说，编写程序时遇到的错误可大致分为 2 类，分别为语法错误和运行时错误。

## 1、Python语法错误

语法错误，也就是解析代码时出现的错误。当代码不符合 Python 语法规则时，Python解释器在解析时就会报出 SyntaxError 语法错误，与此同时还会明确指出最早探测到错误的语句。例如：

	print "Hello,World!"

我们知道，Python 3 已不再支持上面这种写法，所以在运行时，解释器会报如下错误：

	SyntaxError: Missing parentheses in call to 'print'

语法错误多是开发者疏忽导致的，属于真正意义上的错误，是解释器无法容忍的，因此，只有将程序中的所有语法错误全部纠正，程序才能执行。

## 2、Python运行时错误

运行时错误，即程序在语法上都是正确的，但在运行时发生了错误。例如：

	a = 1/0

上面这句代码的意思是“用 1 除以 0，并赋值给 a 。因为 0 作除数是没有意义的，所以运行后会产生错误。

在 Python 中，把这种运行时产生错误的情况叫做异常（Exceptions）。

当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的。如果要避免程序退出，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码让程序继续运行，这种根据异常做出的逻辑处理叫作异常处理。

开发者可以使用异常处理全面地控制自己的程序。异常处理不仅仅能够管理正常的流程运行，还能够在程序出错时对程序进行必的处理。大大提高了程序的健壮性和人机交互的友好性。

## 3、try except异常处理

Python 中，用try except语句块捕获并处理异常，其基本语法结构如下所示：

	try:
	    可能产生异常的代码块
	except [ (Error1, Error2, ... ) [as e] ]:
	    处理异常的代码块1
	except [ (Error3, Error4, ... ) [as e] ]:
	    处理异常的代码块2
	except  [Exception]:
	    处理其它异常

该格式中，[] 括起来的部分可以使用，也可以省略。其中各部分的含义如下：

(Error1, Error2,...) 、(Error3, Error4,...)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型。显然，一个 except 块可以同时处理多种异常。

[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型（后续会用到）。

[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。

从try except的基本语法格式可以看出，try 块有且仅有一个，但 except 代码块可以有多个，且每个 except 块都可以同时处理多种异常。

当程序发生不同的意外情况时，会对应特定的异常类型，Python 解释器会根据该异常类型选择对应的 except 块来处理该异常。

try except 语句的执行流程如下：

首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动生成一个异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。

当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块，如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。

事实上，不管程序代码块是否处于 try 块中，甚至包括 except 块中的代码，只要执行该代码块时出现了异常，系统都会自动生成对应类型的异常。但是，如果此段程序没有用 try 包裹，又或者没有为该异常配置处理它的 except 块，则 Python 解释器将无法处理，程序就会停止运行；反之，如果程序发生的异常经 try 捕获并由 except 处理完成，则程序可以继续执行。

举个例子：

	try:
	    a = int(input("输入被除数："))
	    b = int(input("输入除数："))
	    c = a / b
	    print("您输入的两个数相除的结果是：", c )
	except (ValueError, ArithmeticError):
	    print("程序发生了数字格式异常、算术异常之一")
	except :
	    print("未知异常")
	print("程序继续运行")

程序运行结果为：

	输入被除数：a
	程序发生了数字格式异常、算术异常之一
	程序继续运行

上面程序中，第 6 行代码使用了（ValueError, ArithmeticError）来指定所捕获的异常类型，这就表明该 except 块可以同时捕获这 2 种类型的异常；第 8 行代码只有 except 关键字，并未指定具体要捕获的异常类型，这种省略异常类的 except 语句也是合法的，它表示可捕获所有类型的异常，一般会作为异常捕获的最后一个 except 块。

除此之外，由于 try 块中引发了异常，并被 except 块成功捕获，因此程序才可以继续执行，才有了“程序继续运行”的输出结果。

## 4、try except else异常处理

在原本的try except结构的基础上，Python 异常处理机制还提供了一个 else 块，也就是原有 try except 语句的基础上再添加一个 else 块，即try except else结构。

使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。

举个例子：

	try:
	    result = 20 / int(input('请输入除数:'))
	    print(result)
	except ValueError:
	    print('必须输入整数')
	except ArithmeticError:
	    print('算术错误，除数不能为 0')
	else:
	    print('没有出现异常')
	print("继续执行")

可以看到，在原有 try except 的基础上，我们为其添加了 else 块。现在执行该程序：

	请输入除数:4
	5.0
	没有出现异常
	继续执行

如上所示，当我们输入正确的数据时，try 块中的程序正常执行，Python 解释器执行完 try 块中的程序之后，会继续执行 else 块中的程序，继而执行后续的程序。

## 5、try except finally异常处理

Python 异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作。

注意，和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 不是必须的（else 必须和 try except 搭配使用）。

在整个异常处理机制中，finally 语句的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。

基于 finally 语句的这种特性，在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就放在 finally 块中。

Python 垃圾回收机制，只能帮我们回收变量、类对象占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。

读者可能会问，回收这些物理资源，必须使用 finally 块吗？当然不是，但使用 finally 块是比较好的选择。首先，try 块不适合做资源回收工作，因为一旦 try 块中的某行代码发生异常，则其后续的代码将不会得到执行；其次 except 和 else 也不适合，它们都可能不会得到执行。而 finally 块中的代码，无论 try 块是否发生异常，该块中的代码都会被执行。

举个例子：
	try:
	    a = int(input("请输入 a 的值:"))
	    print(20/a)
	except:
	    print("发生异常！")
	else:
	    print("执行 else 块中的代码")   
	finally :
	    print("执行 finally 块中的代码")

运行此程序：

	请输入 a 的值:4
	5.0
	执行 else 块中的代码
	执行 finally 块中的代码

可以看到，当 try 块中代码为发生异常时，except 块不会执行，else 块和 finally 块中的代码会被执行。

再次运行程序：
	请输入 a 的值:a
	发生异常！
	执行 finally 块中的代码

可以看到，当 try 块中代码发生异常时，except 块得到执行，而 else 块中的代码将不执行，finally 块中的代码仍然会被执行。

finally 块的强大还远不止此，即便当 try 块发生异常，且没有合适和 except 处理异常时，finally 块中的代码也会得到执行。例如：

	try:
	    # 发生异常
	    print(20/0)
	finally :
	    print("执行 finally 块中的代码")

程序执行结果为：

	执行 finally 块中的代码
	Traceback (most recent call last):
	  File "D:\python3.6\1.py", line 3, in <module>
	    print(20/0)
	ZeroDivisionError: division by zero

可以看到，当 try 块中代码发生异常，导致程序崩溃时，在崩溃前 Python 解释器也会执行 finally 块中的代码。

## 5、raise语句，手动引发异常

raise 语句的基本语法格式为：

	raise [exceptionName [(reason)]]

其中，用 [] 括起来的为可选参数，其作用是指定抛出的异常名称，以及异常信息的相关描述。如果可选参数全部省略，则 raise 会把当前错误原样抛出；如果仅省略 (reason)，则在抛出异常时，将不附带任何的异常描述信息。

也就是说，raise 语句有如下三种常用的用法：

raise：单独一个 raise。该语句引发当前上下文中捕获的异常（比如在 except 块中），或默认引发 RuntimeError 异常。

raise 异常类名称：raise 后带一个异常类名称，表示引发执行类型的异常。

raise 异常类名称(描述信息)：在引发指定类型的异常的同时，附带异常的描述信息。


## 6、常见异常

AssertionError	当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常	

AttributeError	当试图访问的对象属性不存在时抛出的异常	

IndexError	索引超出序列范围会引发此异常	

KeyError	字典中查找一个不存在的关键字时引发此异常	

NameError	尝试访问一个未声明的变量时，引发此异常	

TypeError	不同类型数据之间的无效操作	

ZeroDivisionError	除法运算中除数为 0 引发此异常








































